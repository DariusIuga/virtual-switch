!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C	m,member	/struct, and union members/
!_TAG_KIND_DESCRIPTION!C	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C	1.1	/current.age/
!_TAG_PARSER_VERSION!C++	1.1	/current.age/
!_TAG_PARSER_VERSION!Make	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/vercingetorix/Documents/Facultate/RL/Teme/virtual-switch/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/v6.1.0/
!_TAG_ROLE_DESCRIPTION!C!function	foreigndecl	/declared in foreign languages/
!_TAG_ROLE_DESCRIPTION!C!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!C!struct	foreigndecl	/declared in foreign languages/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
$(BINARY)	Makefile	/^$(BINARY): $(OBJECTS)$/;"	t
.c.o	Makefile	/^.c.o:$/;"	t
BINARY	Makefile	/^BINARY=$(PROJECT)$/;"	m
CC	Makefile	/^CC=gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS=-c -Wall -Werror -Wno-error=unused-variable$/;"	m
DIE	include/lib.h	/^#define DIE(/;"	d
INCFLAGS	Makefile	/^INCFLAGS=$(foreach TMP,$(INCPATHS),-I$(TMP))$/;"	m
INCPATHS	Makefile	/^INCPATHS=include$/;"	m
LDFLAGS	Makefile	/^LDFLAGS=$/;"	m
LIBFLAGS	Makefile	/^LIBFLAGS=$(foreach TMP,$(LIBPATHS),-L$(TMP))$/;"	m
LIBPATHS	Makefile	/^LIBPATHS=.$/;"	m
LIBRARY	Makefile	/^LIBRARY=nope$/;"	m
MAX_PACKET_LEN	include/lib.h	/^#define MAX_PACKET_LEN /;"	d
OBJECTS	Makefile	/^OBJECTS=$(SOURCES:.c=.o)$/;"	m
PROJECT	Makefile	/^PROJECT=switch$/;"	m
QUEUE_H	include/queue.h	/^#define QUEUE_H$/;"	d
SOURCES	Makefile	/^SOURCES=lib\/queue.c lib\/list.c lib\/lib.c$/;"	m
SWITCH_ID	Makefile	/^SWITCH_ID ?= 1$/;"	m
SWITCH_NUM_INTERFACES	include/lib.h	/^#define SWITCH_NUM_INTERFACES /;"	d
_LIST_H_	include/list.h	/^#define _LIST_H_$/;"	d
_SKEL_H_	include/lib.h	/^#define _SKEL_H_$/;"	d
__anon11d1a2b3010a	include/protocols.h	/^  {$/;"	u	struct:icmphdr
__anon11d1a2b30208	include/protocols.h	/^    {$/;"	s	union:icmphdr::__anon11d1a2b3010a
__anon11d1a2b30308	include/protocols.h	/^    {$/;"	s	union:icmphdr::__anon11d1a2b3010a
__unused	include/protocols.h	/^      uint16_t        __unused;$/;"	m	struct:icmphdr::__anon11d1a2b3010a::__anon11d1a2b30308	typeref:typename:uint16_t
all	Makefile	/^all: $(SOURCES) $(BINARY)$/;"	t
arp_header	include/protocols.h	/^struct arp_header {$/;"	s
cdr_and_free	lib/list.c	/^list cdr_and_free(list l)$/;"	f	typeref:typename:list
cell	include/list.h	/^struct cell$/;"	s
check	include/protocols.h	/^    uint16_t   check;    \/\/ checksum     -> Since we modify TTL,$/;"	m	struct:iphdr	typeref:typename:uint16_t
checksum	include/protocols.h	/^  uint16_t checksum;$/;"	m	struct:icmphdr	typeref:typename:uint16_t
clean	Makefile	/^clean:$/;"	t
code	include/protocols.h	/^  uint8_t code;                \/* type sub-code *\/$/;"	m	struct:icmphdr	typeref:typename:uint8_t
cons	lib/list.c	/^list cons(void *element, list l)$/;"	f	typeref:typename:list
daddr	include/protocols.h	/^    uint32_t   daddr;    \/\/ the destination of the packet$/;"	m	struct:iphdr	typeref:typename:uint32_t
echo	include/protocols.h	/^    } echo;                        \/* echo datagram *\/$/;"	m	union:icmphdr::__anon11d1a2b3010a	typeref:struct:icmphdr::__anon11d1a2b3010a::__anon11d1a2b30208
element	include/list.h	/^  void *element;$/;"	m	struct:cell	typeref:typename:void *
ether_dhost	include/protocols.h	/^    uint8_t  ether_dhost[6]; \/\/adresa mac destinatie$/;"	m	struct:ether_header	typeref:typename:uint8_t[6]
ether_header	include/protocols.h	/^struct  ether_header {$/;"	s
ether_shost	include/protocols.h	/^    uint8_t  ether_shost[6]; \/\/adresa mac sursa$/;"	m	struct:ether_header	typeref:typename:uint8_t[6]
ether_type	include/protocols.h	/^    uint16_t ether_type;     \/\/ identificator protocol encapsulat$/;"	m	struct:ether_header	typeref:typename:uint16_t
frag	include/protocols.h	/^    } frag;                        \/* path mtu discovery *\/$/;"	m	union:icmphdr::__anon11d1a2b3010a	typeref:struct:icmphdr::__anon11d1a2b3010a::__anon11d1a2b30308
frag_off	include/protocols.h	/^    uint16_t   frag_off; \/\/ we don't use fragmentation, set to 0$/;"	m	struct:iphdr	typeref:typename:uint16_t
gateway	include/protocols.h	/^    uint32_t        gateway;        \/* gateway address *\/$/;"	m	union:icmphdr::__anon11d1a2b3010a	typeref:typename:uint32_t
get_interface_ip	lib/lib.c	/^char *get_interface_ip(int interface)$/;"	f	typeref:typename:char *
get_interface_mac	lib/lib.c	/^void get_interface_mac(int interface, uint8_t *mac)$/;"	f	typeref:typename:void
get_interface_name	lib/lib.c	/^char *get_interface_name(int interface)$/;"	f	typeref:typename:char *
get_sock	lib/lib.c	/^int get_sock(const char *if_name)$/;"	f	typeref:typename:int
head	lib/queue.c	/^	list head;$/;"	m	struct:queue	typeref:typename:list	file:
hex2byte	lib/lib.c	/^int hex2byte(const char *hex)$/;"	f	typeref:typename:int
hex2num	lib/lib.c	/^static int hex2num(char c)$/;"	f	typeref:typename:int	file:
hlen	include/protocols.h	/^	uint8_t hlen;    \/* Length of hardware address *\/$/;"	m	struct:arp_header	typeref:typename:uint8_t
htype	include/protocols.h	/^	uint16_t htype;   \/* Format of hardware address *\/$/;"	m	struct:arp_header	typeref:typename:uint16_t
hwaddr_aton	lib/lib.c	/^int hwaddr_aton(const char *txt, uint8_t *addr)$/;"	f	typeref:typename:int
icmphdr	include/protocols.h	/^struct icmphdr$/;"	s
id	include/protocols.h	/^      uint16_t        id;$/;"	m	struct:icmphdr::__anon11d1a2b3010a::__anon11d1a2b30208	typeref:typename:uint16_t
id	include/protocols.h	/^    uint16_t   id;       \/\/ id of this packet$/;"	m	struct:iphdr	typeref:typename:uint16_t
ihl	include/protocols.h	/^    uint8_t    ihl:4, version:4;   \/\/ we use version = 4$/;"	m	struct:iphdr	typeref:typename:uint8_t:4
init	lib/lib.c	/^int init(int argc, char *argv[])$/;"	f	typeref:typename:int
interfaces	lib/lib.c	/^int interfaces[SWITCH_NUM_INTERFACES];$/;"	v	typeref:typename:int[]
iphdr	include/protocols.h	/^struct iphdr {$/;"	s
list	include/list.h	/^typedef struct cell *list;$/;"	t	typeref:struct:cell *
mtu	include/protocols.h	/^      uint16_t        mtu;$/;"	m	struct:icmphdr::__anon11d1a2b3010a::__anon11d1a2b30308	typeref:typename:uint16_t
next	include/list.h	/^  list next;$/;"	m	struct:cell	typeref:typename:list
op	include/protocols.h	/^	uint16_t op;    \/* ARP opcode (command) *\/$/;"	m	struct:arp_header	typeref:typename:uint16_t
plen	include/protocols.h	/^	uint8_t plen;    \/* Length of protocol address *\/$/;"	m	struct:arp_header	typeref:typename:uint8_t
protocol	include/protocols.h	/^    uint8_t    protocol; \/\/ don't care$/;"	m	struct:iphdr	typeref:typename:uint8_t
ptype	include/protocols.h	/^	uint16_t ptype;   \/* Format of protocol address *\/$/;"	m	struct:arp_header	typeref:typename:uint16_t
queue	include/queue.h	/^typedef struct queue *queue;$/;"	t	typeref:struct:queue *
queue	lib/queue.c	/^struct queue$/;"	s	file:
queue_create	lib/queue.c	/^queue queue_create(void)$/;"	f	typeref:typename:queue
queue_deq	lib/queue.c	/^void *queue_deq(queue q)$/;"	f	typeref:typename:void *
queue_empty	lib/queue.c	/^int queue_empty(queue q)$/;"	f	typeref:typename:int
queue_enq	lib/queue.c	/^void queue_enq(queue q, void *element)$/;"	f	typeref:typename:void
receive_from_link	lib/lib.c	/^ssize_t receive_from_link(int intidx, char *frame_data)$/;"	f	typeref:typename:ssize_t
recv_from_any_link	lib/lib.c	/^int recv_from_any_link(char *frame_data, size_t *length) {$/;"	f	typeref:typename:int
run_switch	Makefile	/^run_switch: all$/;"	t
saddr	include/protocols.h	/^    uint32_t   saddr;    \/\/ source address$/;"	m	struct:iphdr	typeref:typename:uint32_t
send_to_link	lib/lib.c	/^int send_to_link(int intidx, char *frame_data, size_t len)$/;"	f	typeref:typename:int
sequence	include/protocols.h	/^      uint16_t        sequence;$/;"	m	struct:icmphdr::__anon11d1a2b3010a::__anon11d1a2b30208	typeref:typename:uint16_t
sha	include/protocols.h	/^	uint8_t sha[6];  \/* Sender hardware address *\/$/;"	m	struct:arp_header	typeref:typename:uint8_t[6]
socket_receive_message	lib/lib.c	/^int socket_receive_message(int sockfd, char *frame_data, size_t *len)$/;"	f	typeref:typename:int
spa	include/protocols.h	/^	uint32_t spa;   \/* Sender IP address *\/$/;"	m	struct:arp_header	typeref:typename:uint32_t
tail	lib/queue.c	/^	list tail;$/;"	m	struct:queue	typeref:typename:list	file:
tha	include/protocols.h	/^	uint8_t tha[6];  \/* Target hardware address *\/$/;"	m	struct:arp_header	typeref:typename:uint8_t[6]
tos	include/protocols.h	/^    uint8_t    tos;      \/\/ we don't use this, set to 0$/;"	m	struct:iphdr	typeref:typename:uint8_t
tot_len	include/protocols.h	/^    uint16_t   tot_len;  \/\/ total length = ipheader + data$/;"	m	struct:iphdr	typeref:typename:uint16_t
tpa	include/protocols.h	/^	uint32_t tpa;   \/* Target IP address *\/$/;"	m	struct:arp_header	typeref:typename:uint32_t
ttl	include/protocols.h	/^    uint8_t    ttl;      \/\/ Time to Live -> to avoid loops, we will decrement$/;"	m	struct:iphdr	typeref:typename:uint8_t
type	include/protocols.h	/^  uint8_t type;                \/* message type *\/$/;"	m	struct:icmphdr	typeref:typename:uint8_t
un	include/protocols.h	/^  } un;$/;"	m	struct:icmphdr	typeref:union:icmphdr::__anon11d1a2b3010a
version	include/protocols.h	/^    uint8_t    ihl:4, version:4;   \/\/ we use version = 4$/;"	m	struct:iphdr	typeref:typename:uint8_t:4
